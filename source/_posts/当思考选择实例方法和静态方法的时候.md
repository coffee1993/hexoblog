title: 当思考选择实例方法和静态方法的时候
date: 2016-03-17 12:44:52
tags:
categories:
- 编程之美
---
>在写项目的时候，遇到一个wifi模块的工具类，我把它做成了单例模式，但是为何不把它做成实例，或者全是静态方法呢，开发中也常常考虑这些方法用类的实例的对象调用，还是用静态的方法直接调用，这个问题可能很多的程序员都思考过，我们到底如何选择呢？

<!-- more -->


### 简单的说：
- 静态方法：

    ```java
      class Test{
        public static void method(){
          ...
        }

        //方法调用
        main(){
          Test.method();
        }
      }

    ```

- 实例方法

    ```java
      class Test{
        public void method(){
          ...
        }

        //方法调用
        main(){
          Test test = new Test();
          test.method();
        }
      }

    ```

>以java为例，如果要谈他们如何初始化，需要从类加载机制说起，先说结论吧：

### 结论：
>那就是实例化方法更多被使用和稳妥，静态方法少使用。

### 引用

> 为此我查了很多资料，找到一篇访问,借来引用一下：

以“你怎么理解并使用静态方法和实例化方法的？”这样的问题询问了多位程序员，他们开发的语言也不尽相同（c 、c++、java、c#）

以下是他们的回答：

---

海龙说：

公用的方法，而且是一些零散的 一般用静态方法

---

张伟说：

**几乎没有区别**，如果不需要实例化，就用静态方法；如果为了稳妥，就用实例方法，这样才可调用其他实例方法和变量 。

---

萧远山说：

*静态方法比较少用，因为他在一启动就实例化了，比较占资源*，当然,配合单例模式还是比较好用的
比较多的用在数据连接上，我避免使用的原则就是减少资源消耗。

---

张新波说：

静态方法意味着我在调用前不需要进行对其所属的类进行new操作，我主要会在工具类里面用到静态方法。

---


向详说：

静态就是类的，实例就是对象的。
静态方法和实例方法的区别之处还有一个地方：**静态方法不需要依赖类当中的属性** ，能在这个方法中封闭的完成一个功能。实例方法更多的会使用到类当中的属性。

---

winson_张林说：

*最大的区别在于内存*。
*静态方法在程序开始时生成内存,实例方法在程序运行中生成内存*，
所以静态方法可以直接调用,实例方法要先成生实例,通过实例调用方法，*静态速度很快,但是多了会占内存。*
任何语言都是对内存和磁盘的操作,至于是否面向对象,只是软件层的问题,底层都是一样的,只是实现方法不同。
*静态内存是连续的,因为是在程序开始时就生成了,而实例申请的是离散的空间,所以当然没有静态方法快，
而且静态内存是有限制的，太多了程序会启动不了。*

---

showlover说:

静态方法与实例方法各有自己的用处...

是定义成静态方法,还是定义成实例方法,还要看具体情况,比如 **方法本身与类型没有太大的关系,可以定义成静态方法.**

用实例方法,当然需要你先创建实例,才能调用实例方法,而静态方法则不需要..

从性能上说,静态方法效率要稍微高一些,但是它会常驻内存...
一些情况下使用静态方法是有好处的，因为对于静态方法无论你有多少个实例，
内存中要维护的一份拷贝。同时，某些方法，确实使用静态是比较恰当的..

---

Q.yuhen说:

这个问题牵扯到的东西比较多，诸如设计模式等等。简单点说，**静态方法用来执行无状态的一个完整操作，实例方法则相反，它通常是一个完整逻辑的一部分，并且需要维护一定的状态值。**

**如果用内存和效率来区分使用Static Method、Instance Method 就回到过去结构化编程了。使用那种方法的根本出发点还是围绕面向对象来进行的**。

---

陈亮说：

静态方法和全局函数差不多的，实例方法是一个类里面的方法。

---

### 网上有些博客有误的说明：

>静态方法与非静态方法的区别  

- 静态方法（Static Method）与静态成员变量一样，属于类本身，在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。

- 非静态方法（Non-Static Method）又叫实例化方法，属于实例对象，实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。

- 在内存中存储位置
  - 静态方法和静态变量创建后始终使用同一块内存，是连续的。

  - 非静态方法会存在于内存的多个地方，是离散的。
  - 静态方法在堆上分配内存，实例方法在堆栈上。

- 效率
  - 静态方法常驻内存，实例方法不是，所以静态方法效率高但占内存
  - 静态方法的使用效率比非静态方法的效率高。

- 线程安全

  - 静态方法是共享代码段，静态变量是共享数据段。既然是“共享”就有并发（Concurrence）的问题。

  - 非静态方法是针对确定的一个对象的，所以不会存在线程安全的问题。

- 使用范围

  - 静态方法：
    - 1.有静态属性的类，一般会定义静态方法。
    - 2.没有属性的类，一般会定义静态方法。
    - 3.如果一个方法与他所在类的实例对象无关，那么它就应该是静态的。静态方法可以被继承但是不能被覆盖。
  - 实例方法
    - 1.需要先创建实例才可以调用，比较麻烦，静态方法不用，比较简单。


- 总计
  - 如果静态方法在系统中定义太多，会占用大量的资源，最后造成内存溢出，所以静态方法不能滥用。如果从线程安全、性能、兼容性上来看，选用实例化方法为宜。



### 我的总结：

>查阅资料,上面的牛人大多都有一致的观点，但也有我们常提到的几个误区，以下是正确的结论：
- 1.静态方法和实例方法其实在性能上没有区别，加载时机，和内存占用都一样，调用速度也没有区别。
- 2.早期的结构化编程，几乎所有的方法都是“静态方法”，引入实例化方法概念是面向对象概念出现以后的事情了，区分静态方法和实例化方法不能单单从性能上去理解，创建c++,java,c#这样面向对象语言的大师引入实例化方法一定不是要解决什么性能、内存的问题，而是为了让开发更加模式化、面向对象化。这样说的话，静态方法和实例化方式的区分是为了解决模式的问题。
- 3.开发时如何选择：
  - 从面向对象的角度上来说，在抉择使用实例化方法或静态方法时，应该根据是否该方法和实例化对象具有逻辑上的相关性，如果是就应该使用实例化对象  反之使用静态方法，其实用两个方法在效率和性能上影响并不大，根据自己程序设计来解决问题。


>引用链接：http://www.cnblogs.com/chinhr/archive/2008/04/03/1135561.html
